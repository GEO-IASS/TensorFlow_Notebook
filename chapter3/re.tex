\chapter{re}
\section{正则表达式介绍}
\begin{center}
\begin{tabular}{|p{1cm}|p{8cm}|p{6cm}|}
\hline
操作符 & 说明 & 实例\\
\hline
\text{[]} &字符集合，对单个字符给出取值范围  & \text{[abc]}表示a,b,c,\text{[a-z]}表示a到z的单个字符\\
\hline
.& 任何单个字符 &\\
\hline
\text{[]} & 字符集合，对单个字符给出取值范围 & \text{[abc]}表示a,b,c,\text{[a-z]}表示a到z的单个字符\\
\hline
\text{[\quad\^ \quad]}&非字符集，对单个字符给出排除范围&\text{[\^ abc]}表示非a或者b或者c的单个字符\\
*&前一个字符0次或者无限次扩展&abc*表示ab,abc,abcc等\\
\hline
+&前一个字符1次或无限次扩展&abc+表示abc,abcc,abccc等\\
\hline
?&前一个字符0次或者一次扩展&abc?表示ac,abc\\
\hline
|&左右表达式任一个&abc|def表示abc或者def\\
\hline
\{m\}&扩展前一个字符m次&ab\{2\}c表示abc,abbc\\
\{m,n\}&扩展前一个字符m到n次，包含n&ab\{1,2\}c表示abc,abbc\\
\hline
\^&匹配字符串开头&\^{}abc表示abc且在一个字符串开头\\
\hline
\$&匹配字符串结尾&abc表示abc且在一个字符串的结尾\\
\hline
()&分组标记，内部只能使用|操作符&(abc)表示abc，(abc|def)表示abc或者def\\
\hline
\textbackslash d&数字等价与[0-9]&\\
\hline
\textbackslash w&单词字符，等价与[A-Za-z0-9\_]&\\
\hline
\end{tabular}
\end{center}
正则表达式的语法实例
\begin{center}
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
P(Y|YT|YTH|YTHO)?N&'PN','PYN','PYTN','PYTHN','PYTHON'\\
\hline
PYTHON+&'PYTHON','PYTHONN','PYTHONNN',\ldots\\
\hline
PY[TH]ON&'PYTON','PYHON'\\
\hline
PY[\^TH]?ON&'PYON','PYaON','PYbON','PYcON',\ldots\\
\hline
PY\{:3\}N&'PN','PYN','PYYN','PYYYN',\ldots\\
\hline
\end{tabular}
\end{center}
常用的正则表达式:
\begin{center}
\begin{tabular}{||c|c||}
\hline
\^\text{[A-Za-Z]+\$}&26个字母组成的字符串\\
\hline
\^\text{[A-Za-z0-9]}+\$&由26个字母和数字组成的字符串\\
\hline
\^\quad-?\textbackslash d+\$&整数形式的字符串\\
\hline
\^\text{[0-9]}*\text{[1-9][0-9]}* \$&正整数形式的字符串\\
\hline
\text{[1-9]}\textbackslash d{5}&中国境内邮政编码，6位\\
\hline
\text{[\textbackslash u4e00-\textbackslash u9fa5]}&匹配中文字符\\
\hline
\textbackslash d\{3\}-\textbackslash d\{8\}|\textbackslash d\{4\}-\textbackslash d\{7\}&国内电话号码，010-68913536\\
\hline

\end{tabular}
\end{center}
匹配IP地址的正则表达式：
\textbackslash d+.\textbackslash d+.\textbackslash d+或者\textbackslash\{1,3\}.
精确写法:\newline
0-99:[1-9]?\textbackslash d\newline
100-199:1\textbackslash d\{2\}\newline
200-249:2[0-4]?\textbackslash d\newline
250-255:25[0-5]\newline
IP地址的正则表达式:(([1-9]?\textbackslash d|1\textbackslash d\{2\}|2[0-4]\textbackslash d|25[0-5]).)\{3\}([1-9]?\textbackslash d|1\textbackslash d\{2\}|2[0-4]\textbackslash d|25[0-5]
\section{RE库的主要功能函数}
\begin{center}
\begin{tabular}{|l|l|}
\hline
re.search()&在一个字符串搜索匹配正则表达式的第一个位置。\\
\hline
re.match()&从一个字符的开始为值起匹配正则表达式，返回match对象。\\
\hline
re.findall()&搜索字符串，以列表类型返回全部匹配的字串\\
\hline
re.split()&将一个字符串按照正则表达式匹配结果进行分割，返回列表类型\\
\hline
re.finditer()&搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素时match对象\\
\hline
re.sub()&在字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。\\
\hline
\end{tabular}
\end{center}
re.search(pattern,string,flags=0):在一个字符串中搜索匹配正则表达式的第一个位置返回match对象。\par
\begin{itemize}
\item pattern:正则表达式的字符串或原声字符串表示。
\item string:待匹配字符串。
\item flags:正则表达式使用时的控制标记。\newline
\begin{tabular}{|c|c|}
\hline
re.I &忽略正则表达式的大小写，[A-Z]能够匹配小写。\\
\hline
re.M &正则表达式中的\^操作能够将给定字符串的每一行当作匹配开始\\
\hline
re.S &正则表达式中的.操作能够匹配所有的字符，默认匹配除换行外的所有字符\\
\hline
\end{tabular}
\end{itemize}
\begin{python}
import re
match = re.match(r'1\d{5}','BIT 100081')
if match:
    match.group(0)
\end{python}
re.match(pattern,string,flags=0):从一个字符串的开始位置起匹配正则表达式，返回match对象。
\begin{python}
import re
match = re.match(r'1\d{5}','100081 BIT')
if match:
    print(match.group(0))
\end{python}
re.findall(pattern,string,flags=0):搜索字符串，以列表类型返回能匹配的子串。
\begin{python}
import re
ls = re.findall(r'1\d{5}','BIT 100081 TSU100084')
\end{python}
re.split(pattern,string,maxsplit = 0,flags=0):将字符串按照正则表达式匹配结果进行分割，
返回列表类型。\newline
maxsplit:最大分割数，剩余部分作为最后一个元素输出。\newline
\begin{python}
import re
re.split(r'1\d{5}','BIT100081 TSU100084')
re.split(r'1\d{5}','BIT100081 TSU100084',maxsplit=1)
\end{python}
re.finditer(pattern,string,flags=0):搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素时matchdurian。
\begin{python}
import re
for m in re.finditer(r'1\d{5}','BIT100081 TSU100084'):
    if m:
        print(m.group(0))
\end{python}
re.sub(pattern,repl,string,count=0,flags=0)
在一个字符串中替换所有匹配正则表达式的子串返回替代厚的字符串。
\begin{itemize}
\item repl:替换匹配字符串的字符串
\item string:待匹配字符串
\item count:匹配的最大替换次数
\end{itemize}
\begin{python}
import re
re.sub(r'1\d{5}','110','BIT100081 TSU100084')
\end{python}
Re库的另一种等价用法:
\begin{python}
rst = re.search(r'1\d{5}','BIT 100081')
\end{python}
等价于
\begin{python}
pat = re.compile(r'1\d{5}')
pat.search('BIT 100081')
\end{python}
\begin{center}
\begin{tabular}{|l|l|}
\hline
regex.search&在字符串中搜索匹配正则表达式的第一个位置，返回match对象\\
\hline
regex.match()&在字符串的开始为值起配置正则表达式，返回match对象\\
\hline
regex.findall()&所有字符串，以列表类型返回全部能匹配的子串\\
\hline
regex.split()&将字符串按照正则表达式匹配结果进行分割，返回列表类型。\\
\hline
regex.finditer()&搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象\\
\hline
reg.sub()&在一个字符串中替换所有匹配正则表达式的子串，返回替换手的字符串\\
\hline
\end{tabular}
\end{center}
Match对象：一次匹配的结果，包含匹配的很多信息。
\begin{python}
match = re.search(r'1'\d{5},'BIT 100081')
if match:
    print(match.group(0))
type(match)
\end{python}
match对象的属性和方法
\begin{center}
\begin{tabular}{|l|l|}
.string&待匹配的文本\\
.re&匹配时使用的patter对象(正则表达式)\\
.pos&正则表达式搜索文本的开始位置\\
.endpos&正则表达式搜索文本的结束位置\\
.group(0)&获得匹配后的字符串\\
.start()&匹配字符串在原始字符串的开始位置\\
.end()&匹配字符串的将诶数位置\\
.span()&返回(.start(),.end())\\
\end{tabular}
\end{center}
Re库默认采用贪婪匹配，即输出匹配最长的字子串
\begin{python}
match = re.search(r'PY.*N','PYANBNCNDN')
match.group(0)
\end{python}
通常搜索的时候PYAN就能匹配出结果但是根据贪婪匹配，匹配待匹配字符串中最长的字符串。
输出最短子串PYAN。
\begin{python}
match = re.search(r'PY.*?N','PYANBNCNDN')
\end{python}
最小匹配操作符
\begin{tabular}{|l|l|}
\hline
操作符&说明\\
\hline
*?&前一个字符0次或者无限次扩展，最小匹配\\
\hline
+?&前一个字符1次或者浮现次扩展，最小匹配\\
\hline
??&前一个字符0次或者1次扩展，最小匹配\\
\hline
\{m,n\}?&扩展前一个字符串m到n次(含n)，最小匹配\\
\hline
\end{tabular}
\begin{quote}
本章内容借鉴与北京理工大学的嵩天老师的python正则表达式相关内容。
\end{quote}
